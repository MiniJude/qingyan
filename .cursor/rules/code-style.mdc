---
description: 
globs: 
alwaysApply: true
---

### 1. **Unocss样式使用**
- 在给组件应用Unocss样式时，务必使用`class=""`进行包裹，避免直接将样式作为属性使用。

### 2. **样式书写规范**
- 在编写新的HTML代码时，尽可能使用Unocss来完成样式的设置。
- 对于第三方组件的非根节点样式，建议使用SCSS进行处理。

### 3. **遵循DRY原则**
- 在编写业务代码（HTML、JS等）时，务必遵循**DRY（Don't Repeat Yourself）原则**，尽可能复用代码，减少重复部分。

### 4. **定义组件的props**
- 在定义组件的`props`时，按照以下示例进行规范：
  
  ```typescript
  // 定义组件的props
  interface Props {
    columns: ColumnItem[]
    activeIndex?: number
    /** switch_item的固定宽度，不传则自适应各自的宽度 */
    itemWidth?: number
  }
  
  const props = withDefaults(defineProps<Props>(), {
    activeIndex: 0,
  })
  ```

### 5. **页面跳转处理**
- 页面跳转的触发元素如果真实展示在DOM中，必须使用`NuxtLink`进行跳转，这有利于SEO优化。
- 页面跳转时，必须使用`localePath`函数来包裹跳转路径，因为项目使用了国际化。`localePath`可以返回当前语言下的目标路径：

  ```ts
  const localePath = useLocalePath()

  router.push(localePath('/xxx'))
  ```

  如果使用`NuxtLink`实现跳转，示例如下：

  ```html
  <NuxtLink :to="localePath('/xxx')">
  ```

### 6. **函数声明方式**
- 在编写生成函数时，**请使用`function`声明**，避免使用`const`来声明函数表达式：

  ```ts
  function add() {}
  // don't
  const add = () => {}
  ```


### 7. **优先使用Element-plus组件**

新增html代码时，优先使用项目的组件库Element-plus来实现。比如：
- 要用el-button，而不要用button
- 上传相关优先使用el-upload，而不是手写拖拽等实现上传


### 8. **业务组件职责分离**

- 封装业务组件时，如果和其父组件没有明显联动需求，就无需向父组件暴露方法或者emit事件

### 9. **使用async await的异步编程风格**

- 在涉及到异步编程时，请使用async await的编程风格，不要使用Promise.then的风格
- 捕获异常时请使用try catch，不要使用Promise.catch

比如：
```ts
// should:
async function submitRegister() {
  try {
    await registerFormRef.value?.validate()
    // 校验成功
  } catch (error) {
    // 校验失败
  }
}

// don't:
function submitRegister() {
  registerFormRef.value?.validate((valid) => {
    if (valid) {
      // 校验成功
    } else {
      // 校验失败
    }
  })
}
```



